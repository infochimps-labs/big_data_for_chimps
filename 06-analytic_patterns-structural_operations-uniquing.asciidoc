
=== Finding Duplicate and Unique Records


==== Eliminating Duplicate Records from a Table

The park_teams table has a row for every season. To find every distinct pair of team and home ballpark, use the DISTINCT operator. This is equivalent to the SQL statement `SELECT DISTINCT player_id, team_id from batting;`.

------
tm_pk_pairs_many = FOREACH park_teams GENERATE team_id, park_id;
tm_pk_pairs = DISTINCT tm_pk_pairs_many;
-- -- ALT     ALT01
-- -- ANA     ANA01
-- -- ARI     PHO01
-- -- ATL     ATL01
-- -- ATL     ATL02
------

Don't fall in the trap of using a GROUP statement to find distinct values:

------
dont_do_this = FOREACH (GROUP tm_pk_pairs_many BY (team_id, park_id)) GENERATE
  group.team_id, group.park_id;
------


The DISTINCT operation is able to use a combiner, eliminating duplicates at the mapper before shipping them to the reducer. This is a big win when there are frequent duplicates, especially if duplicates are likely to occur near each other. For example, duplicates in web logs (from refreshes, callbacks, etc) will be sparse globally, but found often in the same log file.

The combiner may impose a minor penalty when there are very few or very sparse duplicates. In that case, you should still use DISTINCT, but disable combiners with the `pig.exec.nocombiner=true` setting.

------
  -- Every team a player has played for
SELECT DISTINCT player_id, team_id from batting;
------

==== Eliminating Duplicate Records from a Group


Eliminate duplicates from a group with the DISTINCT operator inside a nested foreach. Instead of finding every distinct (team, home ballpark) pair as we just did, let's find the list of distinct home ballparks for each team:

------
team_parkslist = FOREACH (GROUP park_teams BY team_id) {
  parks = DISTINCT park_teams.park_id;
  GENERATE group AS team_id, BagToString(parks, '|');
};

EXPLAIN team_parkslist;

-- -- CL1     CHI02|CIN01|CLE01
-- -- CL2     CLE02
-- -- CL3     CLE03|CLE09|GEA01|NEW03
-- -- CL4     CHI08|CLE03|CLE05|CLL01|DET01|IND06|PHI09|ROC02|ROC03|STL05
------

------
SELECT team_id, GROUP_CONCAT(DISTINCT park_id ORDER BY park_id) AS park_ids
  FROM park_team_years
  GROUP BY team_id
  ORDER BY team_id, park_id DESC
  ;
------

==== Eliminating All But One Duplicate Based on a Key

The DataFu `DistinctBy` UDF selects a single record for each key in a bag.

It has the nice feature of being order-preserving: only the first record for a key is output, and all records that make it to the output follow the same relative ordering they had in the input bag,

This gives us a clean way to retrieve the distinct teams a player served in, along with the first and last year of their tenure:define DistinctBy

------
DEFINE DistinctByYear datafu.pig.bags.DistinctBy('0');

pltmyrs = FOREACH bat_seasons GENERATE player_id, year_id, team_id;
player_teams = FOREACH (GROUP pltmyrs BY player_id) {
  pltmyrs_o = ORDER pltmyrs.(team_id, year_id) BY team_id; -- TODO does this use secondary sort, or cause a POSort?
  pltmyrs = DistinctByYear(pltmyrs);
  GENERATE player_id, BagToString(pltmyrs, '|');
};
------

The key is specified with a string argument in the DEFINE statement, naming the positional index(es) of the key's fields as a comma-separated list.

==== Selecting Records with Unique (or with Duplicate) Values for a Key

The DISTINCT operation is useful when you want to eliminate duplicates based on the whole record. But to instead find only rows having a unique
record for its key, or to find only rows having multiple records for its key, do a GROUP BY and then filter on the size of the resulting bag.

On a broadcast a couple years ago, announcer Tim McCarver paused from his regular delivery of the obvious and the officious to note that second baseman Asdrubal Cabrera "is the only player in the majors with that first name". This raises the question: how many other people in the history of baseball similarly are uniquely yclept footnote:[yclept /iˈklept/: by the name of; called.]?

------
uniquely_yclept_g = GROUP   people BY name_first;
uniquely_yclept_f = FILTER  uniquely_yclept_g BY COUNT_STAR(people) == 1;
uniquely_yclept   = FOREACH uniquely_yclept_f GENERATE
  group AS name_first,
  FLATTEN(people.(name_last, player_id, beg_date, end_date)) AS (name_last, player_id, beg_date, end_date);
------

Some of you may be familiar with Honus Wagner, Eppa Rixey, Boog Powell or Yogi Berra. But have you heard recounted the storied diamond exploits of Firpo Mayberry, Zoilo Versalles, Pi Schwert or Bevo LeBourveau?  OK, then how about Mysterious Walker, The Only Nolan, or Phenomenal Smith?  Mul Holland, Sixto
Lezcano, Welcome Gaston or Mox McQuery?  Try asking your spouse to that your next child be named for Urban Shocker, Twink Twining, Pussy Tebeau, Bris
Lord, Boob Fowler, Crazy Schmit, Creepy Crespi, Cuddles Marshall, Vinegar Bend Mizell, or Buttercup Dickerson.

.SQL Equivalent for "Selecting Records with Unique Values for a Key"
------
SELECT nameFirst, nameLast, COUNT(*) AS n_usages
  FROM people
  WHERE    nameFirst IS NOT NULL
  GROUP BY nameFirst
  HAVING   n_usages = 1
  ORDER BY nameFirst
  ;
------

==== More fun with uniques

* Counting Missing Values
* Counting and Identifying Duplicates

==== Identifying duplicated records for a key

  -- group by, then emit bags with more than one size; call back to the won-loss example

Once again, what starts out looking like one of the high-level operations turns into a GROUP BY.

Up above, the allstar table almost led us astray due to the little-known fact that some years featured multiple All-Star games. We can pull out the rows matching those fields:

------
  -- Teams who played in more than one stadium in a year
SELECT COUNT(*) AS n_parks, pty.*
  FROM park_team_years pty
  GROUP BY team_id, year_id
  HAVING n_parks > 1
------

(Do this with games table?)

==== Eliminating rows that have a duplicated value

(ie the whole row isn't distinct,
just the field you're distinct-ing on.
Note: this chooses an arbitrary value from each group

------
SELECT COUNT(*) AS n_asg, ast.*
  FROM allstarfull ast
  GROUP BY year_id, player_id
  HAVING n_asg > 1
  ;
------

=== Set Operations
We've actually met most of the set operations at this point, but it's worth calling them out specifically. Set operations on groups are particularly straightforward thanks to the Datafu package, which offers Intersect, Difference (...)

==== Set Operations on Full Tables

To demonstrate full-table set operations, we can relate the locations of
baseball stadiums with the set of major US cities footnote:[We'll take "major
city" to mean one of the top 60 incorporated places in the United States or
Puerto Rico; see the "Overview of Datasets" (REF) for source information].

We've actually met most of the set operations at this point, but it's worth
calling them out specifically. Set operations on groups are particularly
straightforward thanks to the Datafu package, which offers Intersect,
Difference (...)

Limit our attention to prominent US stadiums:

------
main_parks   = FILTER parks       BY n_games >=  50 AND country_id == 'US';
------

==== Distinct Union

If the only contents of the tables are the set membership keys, finding the
distinct union of two tables is done just how it's spelled: apply union, then
distinct.

------
bball_city_names = FOREACH main_parks   GENERATE city;
major_city_names = FOREACH major_cities GENERATE city;
major_or_bball    = DISTINCT (UNION bball_city_names, major_city_names);
------


For all the other set operations, or when you want to base the distinct union
on keys (rather than the full record), simply do a COGROUP and accept or
reject rows based on what showed up in the relevant groups.

Two notes. First, since COUNT_STAR returns a value of type long, we do the
comparison against `0L` (a long) and not `0` (an int). Second, we test
against `COUNT_STAR(bag)`, and not `SIZE(bag)` or `IsEmpty(bag)`. Those
latter two require actually materializing the bag -- all the data is sent to
the reducer, and no combiners can be used.

==== Distinct Union (alternative method)

Every row in combined comes from one table or the other, so we don't need to
filter.  To prove the point about doing the set operation on a key (rather
than the full record) let's keep around the state, population, and all
park_ids from the city.

------
combined     = COGROUP major_cities BY city, main_parks BY city;

major_or_parks    = FOREACH combined
  GENERATE group AS city, FLATTEN(FirstTupleFromBag(major_cities.(state, pop_2011), ('',0))), main_parks.park_id AS park_ids;
------



==== Set Intersection

Records lie in the set intersection when neither bag is empty.

major_and_parks   = FOREACH (FILTER combined BY (COUNT_STAR(major_cities) > 0L) AND (COUNT_STAR(main_parks) > 0L))
  GENERATE group AS city, FLATTEN(FirstTupleFromBag(major_cities.(state, pop_2011), ('',0))), main_parks.park_id AS park_ids;

==== Set Difference

Records lie in A-B when the second bag is empty.

major_minus_parks = FOREACH (FILTER combined BY (COUNT_STAR(main_parks) == 0L))
  GENERATE group AS city, FLATTEN(FirstTupleFromBag(major_cities.(state, pop_2011), ('',0))), main_parks.park_id AS park_ids;

parks_minus_major = FOREACH (FILTER combined BY (COUNT_STAR(major_cities) == 0L))
  GENERATE group AS city, FLATTEN(FirstTupleFromBag(major_cities.(state, pop_2011), ('',0))), main_parks.park_id AS park_ids;

==== Symmetric Set Difference: (A-B)+(B-A)

Records lie in the symmetric difference when one or the other bag is
empty. (We don't have to test for them both being empty -- there wouldn't be
a row if that were the case)

major_xor_parks   = FOREACH (FILTER combined BY (COUNT_STAR(major_cities) == 0L) OR (COUNT_STAR(main_parks) == 0L))
  GENERATE group AS city, FLATTEN(FirstTupleFromBag(major_cities.(state, pop_2011), ('',0))), main_parks.park_id AS park_ids;

==== Set Equality

Any of the tests described under "Set Operations within Groups" (REF) will
work to determine set equality, but unless you're already calculating one of
the set operations above you should use the "symmetric difference is empty"
test. Doing so is a bit more fiddly than you'd think.

To illustrate the problem, we'll use a pair of trivially equal tables:

------
major_city_names_also = FOREACH major_cities GENERATE city;
major_xor_major = FILTER (COGROUP major_city_names BY city, major_city_names_also BY city)
  BY ((COUNT_STAR(major_city_names) == 0L) OR (COUNT_STAR(major_city_names_also) == 0L));
------

Now you'd think that counting the elements of `major_xor_major` would work.
But since `major_xor_major` is empty, _the FOREACH has no lines to operate
on_. When the two sets of keys are equal, the output file is not a `1` as
you'd expect, it's an empty file.

------
-- Does not work: file is empty when sets are equal
major_equals_major_fail = FOREACH (GROUP major_xor_major ALL) GENERATE
   (COUNT_STAR(major_xor_major) == 0L ? 1 : 0) AS is_equal;
------


Our integer table to the rescue! We keep around a one-record version called
'one_line.tsv' having fields uno (value `1`) and zilch (value `0`)

Now do a COGROUP with our one_line friend and the constant value `1`. Since
there is exactly one possible value for the group key, there will only be one
row in the output.

------
one_line = LOAD '$data_dir/stats/numbers/one_line.tsv' AS (uno:int, zilch:int);

-- will be `1` (true)
major_equals_major = FOREACH (COGROUP one_line BY uno, major_xor_major BY 1)
  GENERATE (COUNT_STAR(major_xor_major) == 0L ? 1 : 0) AS is_equal;

-- will be `0` (false)
major_equals_parks = FOREACH (COGROUP one_line BY uno, major_xor_parks BY 1)
  GENERATE (COUNT_STAR(major_xor_parks) == 0L ? 1 : 0) AS is_equal;
------

------
-- for each team year, the set of players for that year and the next, by doing the first part of a self-join
team_yrpls = FOREACH bat_year GENERATE team_id, year_id, player;
team_y2y = FOREACH (COGROUP team_yrpls BY (team_id, year_id) AS ty1, team_yrpls BY (team_id, year_id-1) AS ty2) GENERATE
    group.team_id AS team_id, group.year_id AS year_id,
    ty1.player_id AS pl1, ty2.player_id AS pl2;

roster_changes_y2y = FOREACH team_y2y {

  -- Distinct Union: the players in each two-year span (given year or the next). SetUnion accepts two or more bags:
  either_year   = SetUnion(pl1, pl2);

  -- the other set operations require sorted inputs. Keep in mind that an ORDER BY within the nested block of a FOREACH (GROUP BY) is efficient, as it makes use of the secondary sort Hadoop provides.
  opl1 = ORDER pl1 BY player_id;
  opl2 = ORDER pl2 BY player_id;

  -- Intersect: for each team-year, the players that stayed for the next year (given year and the next). Requires sorted input. With
  both_years    = Intersect(opl1, opl2);

  -- Difference: for each team-year, the players that did not stay for next year (A minus B). Requires sorted input. With multiple bags of input, the result is everything that is in the first but not in any other set.
  y1_undeparted = SetDifference(opl1, opl2);

  -- Symmetric Difference: for each team-year, the players that did not stay for next year (A minus B) plus (B minus A)
  non_both       = DIFF(opl1,opl2)
  -- TODO validate; also compare SUBTRACT

  -- Set Equality: for each team-year, were the players the same?

  is_unchanged =
    -- if a has no dupes then the elements of a == elements of b if and only if (size(a intersect b) == size(a) == size(b));
    -- if a has no dupes then the elements of a == elements of b if and only if (size(a minus b) = 0 AND (size(a) == size(b))
  TODO is there a Datafu for this

  GENERATE team_id, year_id,
  };
------

All of those methods use in-memory bag operations, which is generally fine.
We can also do this using the summing trick


For set operations on tables, let's compare at the cities that have ever hosted a major league team compare to the largest cities by population. To prove a point about set operations with duplicates, we will leave in the duplicates from the team cities (the Mets and Yankees both claim NY), and seed the largest cities list by concatenating the top 50 by strict population with the cities in the top 25 metro areas.

------
cities = LOAD 'cities-top_25_by_pop';
top_metros = LOAD 'metros-top_25_by_pop';
top_metros = FOREACH top_metros GENERATE FLATTEN(STRSPLITBAG(name,'-')) AS name;

teams = load_teams;
bb_g_popc = COGROUP teams BY city, top_cities BY name;
-- union
bb_union_popc = FOREACH bb_g_popc GENERATE FLATTEN(...)
-- intersect
bb_and_popc = NOT(isEmpty(A) OR isEmpty(B))
-- set difference
bb_minus_popc = isEmptyB
-- symm difference
bb_xor_popc = isEmpty(A) OR isEmpty(B)
-- equality
Count(bb_xor_popc) = 0

-- union if no other fields needed
bb_union_popc_0 = UNION (FOREACH teams GENERATE city), (FOREACH cities GENERATE name AS city);
bb_union_popc_d = DISTINCT bb_union_popc_0;
------


This is also how you would do set operations when the bag sizes were too large, or if you wanted to retain columns not considered in the set operation.


.Set Operation Membership
------
	 A	 B	A∪B	A∩B	a-b	b-a	a^b	 ∅
A B	 T	 T	 T	 T	 F	 F	 F	 F
A -	 T	 F	 T	 F	 T	 F	 T	 F
- B	 F	 T	 T	 F	 F	 T	 T	 F
- -	 F	 F	 F	 F	 F	 F	 F	 F
------
